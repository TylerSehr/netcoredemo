Ripstik: A Permissive Consensus Protocol Using Reusing Its Own Network Requirements as a Sybil Barrier
Abstract
This paper describes Ripstik (Rapid
Interval Permissive Synchronous Throughput- Intensive Konsensus), a Byzantine fault tolerant consensus protocol that represents a unique and efficient hybrid of traditional, strictly permissioned Byzantine fault tolerant consensus protocols, and truly permissionless but resource intensive Nakamoto Consensus. Ripstik reuses the heavy communications requirements of traditional Byzantine fault tolerant consensus protocols in combination with a stringent time limit to allow for the provable contribution of throughput relative to the other nodes. Unlike the raw hash power consumed to “mine” in Nakamoto consensus, the resources used to pass Ripstik’s Sybil barrier are utilized by the protocol itself to attain consensus, allowing for Ripstik to be a very efficient and scalable consensus protocol that is also open to arbitrary nodes. Ripstik is best described as permissive rather than truly permissionless, because, while open to arbitrary nodes, nodes are added via block-chain transactions, thus requiring active participation by nodes already in the network. However, this slight trade-off of openness offers the benefit of dramatically better scalability characteristics, more efficient resource utilization, and the finality of transactions offered by traditional permissioned Byzantine fault tolerant consensus protocols.
1 Introduction
Numerous Byzantine fault tolerant consensus protocols have been proposed and engineered to fulfill the various requirements of applications relying on decentralized computing systems and networks. However, the consensus protocols for such systems have historically fallen into one of two categories, permissioned and permissionless.
Permissioned Byzantine fault tolerant consensus protocols, such as Byzantine Paxos[4] or Sync Hotstuff[1][2], tolerate faulty nodes with
Byzantine behavior, and also offer finality of transactions, but they are susceptible to Sybil attacks, and thus systems attaining consensus through such protocols must be limited to a fixed set of nodes, usually “invited” by a centralized authority, that in itself may be a point of failure.
Permissionless consensus tends to be variants of “Nakamoto Consensus”[3] aka “Proof of Work”, based on the protocol described by the pseudonymous creator of Bitcoin. These protocols rely on imposing a resource barrier (in the case of Bitcoin, hash power, though barriers using other resources, such as disk space, have been implemented), to limit participation to nodes that have provably invested resources into the network, limiting the number of “Sybil Nodes” an attacker can create. While this largely mitigates the Sybil attack, it comes at the cost of making the network enormously resource intensive, with Bitcoin now consuming electricity equal to entire countries[8]. The resources used to overcome the Sybil barrier also serve only to overcome the Sybil barrier, and thus such Sybil barriers are often considered to be very wasteful of resources. Furthermore, these protocols offer only “probabilistic finality” in that no transaction is truly final, but the probability of a longer fork of the chain orphaning the block in which the transaction occurred becomes very low as more blocks are added that extend the block in which the transaction occurred[3].
There have been attempts to capture the best of both design models, with the most prominent designs being described as “Proof of Stake”, in which the staking of existing reward tokens from the network functions as a Sybil barrier, and the network may achieve consensus via a traditional Byzantine fault tolerant consensus protocol. However, such models have been criticized for potential security problems, such as the “Nothing at Stake” attack, or for having a centralizing force due to a “rich get richer” effect caused by the rewards being paid out as a function of staked tokens. Furthermore, they are typically
Greg Tseng
complicated in their implementation, generally much more so than Nakamoto Consensus.
Finally, all of these approaches suffer from potential scalability problems. Traditional Byzantine fault tolerant consensus protocols tend to be very communications heavy, requiring nodes send and receive a large number of messages to and from other nodes. Nakamoto consensus is entirely abstracted from its underlying network infrastructure, and such implementations must limit the throughput to what can be expected to be propagated by a black-box gossip protocol to avoid creating “orphaned blocks”. In the case of Bitcoin, this is set at four megabytes every ten minutes. Proof of Stake designs are also entirely abstracted from their underlying communications infrastructure, and may suffer catastrophic system failure if this underlying infrastructure is overloaded[9].
This document’s contribution, Ripstik, is a Byzantine fault tolerant consensus protocol based on the traditional Byzantine fault tolerant consensus protocol, Sync Hotstuff, but adapted to include a proof-of-work like function that allows nodes to provably contribute throughput to the network. This both functions as a Sybil barrier, and ties the consensus protocol to its underlying network infrastructure, to which participants are incentivized to contribute, allowing for stability and scalability, and the participation of arbitrary nodes without a central authority, nor computational resources wasted on work that exists only to serve as as a Sybil barrier.
2 Description of the Protocol
The protocol shall first be described operating with a static set of nodes, and then shall be extended to operating in a “permissive” mode, allowing for arbitrary nodes to be added to the network.
Ripstik at its core is a traditional Byzantine fault tolerant consensus protocol that is very similar to a lockstep variant of the standard synchronous version of the Sync HotStuff protocol, and as such, the assumptions and procedures are very similar, and many of the same
descriptors as those used by Abraham et al.[1][2] will be used to describe the protocol. However, as Ripstik progresses in lockstep, and honest nodes participating in Ripstik are assumed to have a minimum throughput, the δ and Δ maximum latency times of Sync HotStuff will be replaced with times calculated and expressed in terms of the following known values:
 w, the minimum expected symmetric throughput of a node relative to the other nodes of the network. A node is to be considered faulty if it does not meet this requirement. The word throughput here is to be defined as all logic, calculations, network transmissions, etc needed to for a node to complete the stages of the protocol as a function of time. In practical implementations of this protocol, network bandwidth is likely to be the bottleneck and w will be roughly equal to the bandwidth available to a node.
 n, the number of nodes
 ß, the size of a proposed block  m, the size of a signed vote
Ripstik requires blocks be exactly ß in size, and indeed, when a node proposes a block, the block must be exactly ß in size, and should be padded to reach exactly ß size. Similarly, nodes must not accept blocks, or vote for proposals containing blocks that are not ß in size. This requirement is to force nodes to prove their contribution of network resources to the network, which is essential for constructing a Sybil barrier. As will be further explained in later sections, if nodes are allowed to propose blocks of less than ß in size, they are not proving their contribution of network resources, and if nodes are allowed to propose blocks greater than ß in size, honest nodes meeting the minimum network may not be able to keep up with the steps of the protocol.
Ripstik tolerates a minority of faulty nodes. As such, it shall be assumed that the number of faulty nodes, f, is always such that n ≥ 2f+1.
Tseng 2

Ripstik tolerates both crash faults and Byzantine faults of this minority of nodes.
As Ripstik requires lockstep progression, and nodes are assumed to have clocks that are in sync. An example of such a clock would be an idealized Epoch time, although it should be noted for practical implementations that clocks being slightly out of sync is unlikely to be an issue as long as the deviation is insignificant compared to the network carrier latency (as is generally possible using clock synchronization protocols such as Network Time Protocol).
It shall be assumed that nodes have a method of cryptographically signing messages, and that this cryptography is secure. Furthermore, it shall be assumed that all nodes are able to verify the signatures of all other nodes (i.e., all nodes have each others’ public keys). A message signed by a particular node, N, shall be described as [message]N.
Much like Sync HotStuff, Ripstik progresses in views, as defined by the period of time for which a particular node is acting in the roll of leader. However, unlike Sync Hotstuff, the leader (and thus view) changes for every proposed block, regardless of leader behavior. Leaders are to be selected in round robin order. Messages and votes from a particular view should include the view number, as to avoid having adversaries replay signed votes or proposals in different views. This will be described as [message, v]N, with v representing the view number.
Ripstik progresses its replicated state through blocks of batched transactions to be executed on data points of this replicated state, and said blocks are linked together, as each block, excepting the genesis block, contains the hash digest of its predecessor block. The position of a particular block, B, relative to the genesis block may be expressed as a height, k. As such, block Bk at height k has the following format:
Bk := (bk, H(Bk-1))
The proposed requests for height k are denoted by bk, and H(Bk-1) denotes the hash of the predecessor
block. It shall be assumed that the hash function is ideal and secure. For a block to be valid, it must:  Either specify a valid predecessor block,
or be the genesis block, and,
 its proposed requests must be valid within
the context of the application (i.e., for a ledger type application, transactions must be signed by the spender, and must not double spend).
As in other consensus protocols utilizing a block chain[1], if a block, Bk, is an ancestor of Bl, and l ≥ k, then Bl can be said to extend Bk, and it should be noted that blocks extend themselves. If two different blocks, Bk and Bk*, exist at the same height, or if Bl is at a higher height than Bk, and does not extend Bk, these blocks are said to equivocate each other.
Like Sync HotStuff, Ripstik relies on quorum certificates, which are a set of signed votes occurring in the same view for a block from a quorum of nodes, and, as in Sync HotStuff, a quorum certificate must have a simple majority of votes (ie if the total number of nodes = 2f+1, a quorum certificate consists of f+1 votes for a block). If a block, Bk, has a quorum certificate from view v, its quorum certificate may be written as Cv(Bk), and Bk may be referred to as a certified block. Nodes will keep track of certified blocks, and continuously update the highest certified block to its knowledge. As in Sync HotStuff, nodes will lock on to the highest certified block(s). However, unlike Sync Hotstuff, blocks are ranked purely by height. This is a result of view changes in Ripstik occurring on a lockstep schedule, and the limitation that a leader may only propose one block before the view changes.
It should specifically stated that
committing a block also commits all of its ancestor blocks, as blocks are chained to across heights by hashes. If an ancestor block is committed by a node due to the node committing a block extending it, this shall be referred to as the node indirectly committing the ancestor block, in contrast to the node directly committing the block extending this ancestor.
Tseng 3

2.1 The Stages and Operation of the Protocol
The stages of the protocol for each view are as follows:
Propose. The leader, L, broadcasts a proposal, [propose, v, Bk, Cv-1(Bk-1)]L, to all other nodes. This stage lasts a fixed amount of time, and nodes have a window of time in which they will accept proposals before moving on to the next stage. Looking ahead, the rigid size of the proposal and vote messages, and the limited time in which they must be broadcast creates a Sybil barrier since nodes must have greater than the amount of network bandwidth necessary to broadcast a proposal to all other nodes.
Nodes should remain in this stage for a time equal to:
Itshould n⋅ß+n2⋅m
be noted this w 2⋅ w
amount of time is exactly the time required for a node (in this case, the leader) with bandwidth w to send a proposal consisting of a proposed block of size ß and a quorum of votes for the block’s predecessor, which is 0.5·n votes of size m, to all n nodes of the network.
Vote. If a node, N, received a proposal from L during the propose stage and all the following are true:
 The quorum certificate within the proposal, Cv-1(Bk-1), is valid and certifies a block equal to or greater in height than N’s locked block.
 The proposed block, Bk, is valid with respects to the application, and Bk extends a block certified by the quorum certificate, Cv-1(Bk-1).
 N observed a valid vote message from L in the last view in which L was leader, and N has observed a valid vote message from L in every view since.
If the above are true, N should broadcast a vote message for the proposed block in the form of [vote, [propose, v, Bk, Cv-1(Bk-1)]L, [v, H(Bk)]N]N. It
should be noted that this vote message forwards the proposal, and contains a separately signed vote that may be separately used in a quorum certificate.
If one or more of the above conditions are not met, N should broadcast a null vote, a signed message of the same size as if N had voted for a proposal, but instead consisting of simply null characters.
During this stage, N should also be listening for valid votes from other nodes. A vote message is valid if it is signed, and the correct size for either a vote for a proposal, or a null vote.
Nodes should remain in the vote stage for a time equal to:
n⋅ß+n⋅(n+1)⋅m w 2⋅w
This is exactly the time a node with the minimum bandwidth, w, will take to send either a valid vote for the proposal or null vote to all n nodes. Note: this is slightly longer than the propose stage because votes contain one more signed message than a proposal, that signed message being the nodes own signed vote for the proposal, or an equivalents number of null characters.
After the vote stage has finished:
 If a node, N, has received a quorum of
votes for Bk, it should package the votes into a quorum certificate, Cv(Bk), and send this quorum certificate to the leader of the next view, and Bk is now N’s locked block. If N has not observed a quorum of votes for Bk, it should send the quorum certificate for its locked block to the leader of the next view.
 If a node, N, observes that the proposed block, Bk, has received a quorum of votes, and N has not observed any blocks equivocating Bk-1, then Bk-1 should be committed by N.
Wait. All nodes must wait for an agreed upon time that is long enough for an honest leader to receive
Tseng 4
 
a quorum certificate from all nodes, after which the next propose stage begins. Nodes should remain in this stage for a time equal to:
n2⋅m 2⋅w
This is the time it takes for an honest node with the minimum throughput, w, to receive a quorum certificate consisting of 0.5·n votes of size m from n nodes.
If N is the leader for a view, it should use the quorum certificate of its highest certified block in its proposal. If N has equivocating blocks tied for the highest certified block, it may use either block in its proposal. Note it is possible for two equivocating blocks to obtain quorum certificates in the same view, due to the possibility of Byzantine behavior on the part of the leader, resulting in multiple valid proposals proposing equivocating blocks, and the possibility of Byzantine nodes sending different votes to different nodes. However, if this occurs, all nodes will observe the existence of the equivocating proposals and blocks, as will be proven in the next section.
2.2 Ripstik as a Byzantine Fault Tolerant Consensus Protocol
A consensus protocol must satisfy the following requirements:
 Termination. All nodes will eventually commit a value(s).
 Agreement. All honest nodes commit the same value(s).
 Validity. If an honest node proposes a value, all honest nodes will commit the value it proposes.
It shall also be demonstrated that Ripstik guarantees continued liveness of the protocol.
Lemma 1. If quorum certificate exists for a block, all nodes have observed the proposal proposing the block. In Ripstik, a quorum consists of f+1. As such if a set of f+1 votes exists for a block, at least one honest node must have voted for the block, as it is a given that there are not enough faulty nodes
to form a quorum. When an honest node votes for a block, it broadcasts the proposal that proposed the block to all other nodes. As such, as it impossible for a block to have a quorum certificate without all other nodes having at least seen the proposal proposing the block, as the quorum certificate must contain the vote from at least one honest node that broadcast the proposal to all other nodes when it voted.
As a trivial corollary to this lemma, if a block has a quorum certificate, all other nodes have seen that block since the proposal containing it was broadcast to all other nodes by honest nodes voting for it.
As an additional corollary, it is safe to use simply the hash of a block in vote messages and quorum certificates, as if a block is certified, all nodes have seen the block in un-hashed form in the proposal broadcast by honest nodes voting for it. This is useful in practical implementations of this protocol for reducing the size of votes and quorum certificates.
Lemma 2. Once a block is certified, no block equivocating its ancestor may be certified.
Suppose that block Bk, extending Bk-1, is certified. Due to Lemma 1, for Bk to have been certified, all nodes are guaranteed to have seen the proposal proposing Bk, which is specified to contain the quorum certificate for Bk-1. As such, all nodes are guaranteed to have seen the quorum certificate for Bk-1 during the vote stage in which Bk is certified. If all nodes have seen the quorum certificate for Bk-1, all nodes will be locked onto Bk- 1, or a block of equal or higher height. Thus, any proposal proposing a block that equivocating Bk-1 must contain a quorum certificate for a block of height k-2, and as all nodes are locked onto a block of height greater than or equal to k-1, no honest node will vote for such a proposal/block, and it cannot be certified.
Theorem 3 (Safety of Commits). If an honest node directly commits a block, all certified blocks of greater or equal height must extend this block.
Tseng 5

Suppose for contradiction that node N has committed block Bk-1 due to observing a quorum of votes for Bk, and there exists a non empty set of certified blocks of greater height than Bk-1 that do not extend Bk-1. For such blocks to exist, they must extend a certified block that equivocates Bk-1, as proposals for a block must contain a quorum certificate of the proposed block’s immediate ancestor, and as these blocks are of a height greater than or equal to k-1, they must extend a certified block at height k-1 that is not Bk-1. Let this certified block at height k-1, which is not Bk-1, be Bk-1*. To avoid contradicting Lemma 3, Bk-1* must have been certified prior to N observing the quorum of votes for Bk, and committing Bk-1. However, as N will not have committed Bk-1 if it had observed Bk-1*, it is not possible for Bk-1* to have been certified prior to N observing the quorum of votes without contradicting Lemma 1.
Thus, as it is not possible for Bk-1 to have been committed, and Bk-1* to have been certified, it is not possible for any certified blocks of height k- 1 or greater to exist without contradiction of Lemma 2 or 3.
Lemma 4. If a view has an honest leader, all honest nodes will be locked onto the block proposed by the leader at the end of the frame.
Because all honest nodes have sent their highest quorum certificate to the leader during the last stage of the previous view, and the honest leader will make a proposal containing the highest quorum certificate it receives, the quorum certificate contained within the honest leader’s proposal will be equal to or greater in height than the locked block of all honest nodes. The honest leader will send this proposal to all nodes, including all honest nodes, which will vote for the block contained within the proposal, and, as honest nodes will send their votes to all other nodes, including all other honest nodes, all honest nodes will receive a vote for the block from every other honest node. Since all votes from all honest nodes for a block will constitute a quorum certificate, all honest nodes will observe a quorum certificate for the honest leader’s proposed block. Since the honest leader’s proposed block will be higher than
their previous locked block due to it extending the quorum certificate in the proposal, all nodes will now lock on to the honest leader’s proposed block.
Lemma 5 (Liveness of the Protocol). All honest nodes keep committing new blocks.
Due to the nodes progressing between stages as a function of time rather than action on the part of any particular node, there exists no mechanism by which a faulty node may stall the progression of stages or views, even as leader. Furthermore, due to the constant changing of the leader between views, eventually there will be views with honest leaders.
Next it can be demonstrated that if two views with honest leaders occur consecutively, all honest nodes will commit the block proposed by the first of these honest leaders. Let the first honest leader, L, have proposed block Bk. As proven in Lemma 5, all honest nodes will be locked onto Bk by the end of the first honest leader’s view. If the leader of the next view, L+1, is honest, it will broadcast a proposal, [propose, Bk+1, Cv(Bk)]L+1, to all nodes, and, due to Lemma 5, all honest nodes will vote for this proposal, and observe a quorum for Bk+1. As all honest nodes have seen quorum for Bk, and no equivocating block for Bk will have been observed by any honest node (due to L being honest and sending a proposal extending the highest certified block it knows), all honest nodes will commit Bk.
Finally, it can be shown that it will eventually occur that two honest views will occur consecutively. As it is assumed that faulty nodes are the minority, if f is the number of faulty nodes, the number of honest nodes must be at least f+1. Assuming the worst possible case of views alternating between honest and faulty leaders, a maximum of 2f views may pass with this alternation, due to only f faulty nodes existing. However, as the number of honest nodes must be at least f+1, due to the pigeonhole principle, two consecutive views with honest leaders must occur. It should be noted that for the case of f faulty nodes and exactly f+1 honest nodes, and the alternation starting with an honest node and alternating between honest and faulty for each
Tseng 6

faulty node, there still must exist an honest node at the end of this sequence due to there being f+1 honest nodes, and the two consecutive views with honest nodes will occur when the round robin leadership change “wraps around” and starts over again at the first honest node.
As a corollary to this lemma, it can be stated that, given n ≥ 2f+1, if a block is going to be committed, it will be committed within n views (or after a maximum of 2f views) of it being proposed, i.e. before the node that proposed it is leader again. This also represents the time to finality for a transaction in the Ripstik Protocol, as if a block is committed, all honest nodes will have committed it within n views.
Theorem 6 (Protocol Satisfies the Requirements of Agreement and Termination): If an honest node commits a block, all other honest nodes will either have directly committed this block, or will indirectly commit this block within the bounds established in Lemma 5.
If nodes N and N* are honest nodes, and N directly commits block Bk, there exist two possible scenarios for N*. If N* has also observed a quorum for Bk+1 (or any block extending Bk at height k+1, due to Theorem 3), it will also directly commit Bk. Alternatively, if N* does not observe a quorum for Bk+1, while it will not directly commit Bk, due to Lemma 5, it will eventually commit a block of greater height, and due to Theorem 3, this block must extend Bk. As committing a block indirectly commits all its ancestors, when this commit happens, N* will indirectly commit Bk.
Theorem 7 (Protocol Satisfies the Requirement of Validity): If an honest node proposes a block, all honest nodes will eventually commit its block.
As proven in Lemma 4, if the leader is honest, all nodes will be locked onto its proposed block at the end of its view. As such, all future certified blocks must extend its proposed block. Due to Lemma 5, eventually one of these proposed extending blocks will be committed by all honest nodes, indirectly committing the block proposed by the honest leader.
3 Ripstik with Dynamic Nodes and Sybil Resistance
With a few extra procedures, the consensus protocol as described in Section 2 can be extended to allow for arbitrary nodes to join the network, and for faulty nodes to be removed from the network, and for simultaneous consensus to be achieved on these changes to the state of the network itself.
3.1 Adding and Removing Nodes
As nodes must be aware of all other nodes in the network, it follows that nodes maintain a roster of the other nodes of the network. As such, if a node were to propose an edit to this roster in its proposed block, and a node is able to commit this block, all nodes are guaranteed to have committed this block, with its proposed edit to the roster, after 2f views have occurred (lemma 5 and theorem 6). As such, if the protocol is extended such that nodes may propose adding nodes to the roster in their proposed blocks, and such that, if the block is committed, nodes commit changes to the roster after 2f views have passed since the block was proposed, it is possible for Ripstik to add new nodes with agreement among all nodes on the state of the rosters. Naturally it must be assumed that as new nodes are added, the majority of nodes remain honest.
Similarly, it is possible to remove faulty nodes. If a node has not committed a block that was proposed by node F after 2f views have occurred since F was leader, no other nodes will have committed a block proposed by F, and as such, all honest nodes may remove F from the roster with agreement.
Furthermore, it may be desirable to implement the protocol in such a way such that if equivocating signed proposals or votes are seen from a node in a view, another node may include these in its proposed block as evidence of a node’s faultiness due to the signatures being verifiable by all other nodes. Like the procedure to add nodes, if the block containing the removal proposal is committed and 2f views have passed since its
Tseng 7

proposal, honest nodes will be in agreement on the removal of the faulty node.
3.2 Sybil Resistance
Unlike many Byzantine fault tolerance consensus protocols, Ripstik imposes a barrier against Sybil attacks. Due to the rigid time constraints for each stage of a view, and the rigid size of messages and blocks, the throughput of a node is provable once a block it has proposed is committed. As nodes will not vote for a proposal originating from a node that has not been observed to have voted in every view since it was last leader, if a block it has proposed is committed, it must have received a quorum of votes, and to receive a quorum of votes, it must have sent a valid proposal to at least one honest node, and it must have sent at least one honest node a valid vote in every view. As such, the throughput of a node that is able to propose a block that is eventually committed must be at least w/n. However, this scenario in which it is possible for a faulty node, F, to get a block committed with only w/n throughput is only possible if F is colluding with all other f faulty nodes such that faulty nodes continue to vote for F’s proposals even if F has not sent them votes, and they are able to sign F’s proposals with negligible resource utilization. For example, an attacker may give each node they control a copy of the private key of each other node they control so that when one of their nodes is leader, it does not need to send its proposal to each other attacker node, as each node can sign and broadcast the proposal and vote itself, allowing the attacker to save resources. Assuming the absolute worst case scenario in which n=2f+1, and all f nodes are controlled by an attacker, the attacker would need to have the resources to attain a total throughput of:
f⋅w ≈ w 2⋅f+1 2
Given that the minimum bandwidth of an honest node is w, this may appear to be a very weak Sybil barrier. However, there are a number of implementation techniques that may be used to make this barrier significantly more imposing.
As w represents throughput, which is a function of work over time, any mechanism that forces a would-be attacker to spend more time participating, even at a reduced capacity, will increase the barrier of work needed to compromise the network. An example of this would be limiting the number of new nodes that may be added per round robin cycle through the roster. As such, a would-be Sybil-attacker would be limited in the rate at which they may add new nodes to the network, and any nodes they add must at least participate enough to get blocks committed and avoid being removed from the network. For example, if the attacker can only add one node per rotation through the roster, each node they add must contact and send votes to at least n/2 – a nodes, where a is the number of colluding attacker nodes, meaning the total throughput the attacker must invest can be calculated with the following formula:
a⋅n
(2 −a2)⋅w
n
As a increases from 1 until n/2, at which point the attacker has more than a minority of nodes under their control, the minimum resources used by an attacker increases until the attacker controls 25% of the nodes, at which point they are investing the resources needed to attain a throughput of 6.25% of the entire network’s theoretical throughput, at which point the resources needed will begin to decrease as more colluding attacker nodes are added until reaching w/2 at which point the network is compromised. However, to execute such an attack, not only must the attacker control the resources to achieve a throughput of 6.25%, but they must also control said resources for enough views such that they may do work as a function of the integral of the aforementioned formula.
Tseng 8
  
    50%
Minimum resources invested by a successful attacker as a percentage of total consensus network resources plotted against time necessary for a successful attack, with Bitcoin’s consensus network shown in crosshatching, Ripstik in solid gray. Y axis roughly to scale, X axis scales variably dependent on the implementation of Ripstik, and how many deep blocks the attacker desires to compromise on the Bitcoin network.
Another further modification to increase the Sybil resistance of Ripstik can be simply modifying the protocol such that only the “oldest” nodes, i.e. the nodes that have remained on the roster for the longest, and added the most blocks, may propose new nodes, or impose a minimum number of blocks a node have added before it may propose adding a new node. Both of these modifications will increase the amount an attacker must invest before they are able to compromise the network as a function of forcing attacker nodes to contribute resources for a known amount of time before they are able to add more attacker nodes. Indeed, by limiting the ability to propose new nodes to the oldest nodes on the roster, Ripstik can function as a sort of hybrid Proof of Work/Proof of Authority consensus mechanism. In this case, the number of blocks added by a node represents the work done by the node, and thus its “reputation”. A node that has already provably invested a great deal into the network likely has much more to lose from the network being compromised than a node that has invested less, and is thus less likely to behave maliciously. Empirical studies of real world distributed networks have also found that the likelihood of a node remaining online is roughly a function of their current uptime[5], and
it seems likely that these oldest nodes are the least likely to be faulty in practical implementations.
This is likely to mitigate Sybil attacks, as any party investing such computational and network resources for this amount of time into the network is likely to find it much more profitable to contribute honestly to the network than to compromise the network and devalue/lose whatever rewards and benefits the particular implementation of Ripstik offers to participating nodes, in a manner very similar to how an attacker able to reach the necessary hash rate to compromise Bitcoin would likely find it more profitable to collaborate with rather than compromise the system[3]. It should be noted that while an attacker working against Bitcoin’s consensus mechanism may compromise the block- chain at any point in the block chain, provided they have the resources to redo the work for all higher ranked blocks faster than the honest nodes do, in Ripstik, due to the fact the protocol offers finality, once a block has been committed and is known to be committed by all honest nodes, it may be considered “safe” even from a successful Sybil attack, as, even if an attacker may succeed in subverting the network, they cannot get blocks certified or committed that overwrite these blocks without it being known that a successful attack (Sybil, or otherwise) has occurred, as it is not possible for a block that does not extend a committed block to be certified, barring a state in which more than a minority of nodes are dishonest. Furthermore, it may be possible for the network to recover from this state with relative ease by locking onto the network state of the last roster that did not have an attacker majority.
Finally, it should be noted that increasing the quorum number (and assuming a lower limit for faulty nodes), increases the resources required of an attacker significantly. If the quorum number is increased to 60%, the vertex of the parabola representing the necessary investment of resources by a successful attacker will be moved to 9% of the total network, and if it is increased to 66%, the vertex increases to 11.11%, albeit for a shorter duration, as the number of nodes an attacker needs
Tseng 9
  
to infiltrate to subvert the network (40% and 33%, respectively), is decreased.
4 Practical Implementation and Scalability of Ripstik
Ripstik is an algorithm that is designed to be scalable and straightforward to implement in real world networks. This section will briefly discuss some of the design decisions and optimizations that should be considered for the real world implementation of Ripstik.
4.1 Adjusting Parameters for the Carrier Technology
As discussed in section 2, Ripstik is configurable with a set of parameters that must be agreed on ahead of time by all nodes. While the number of nodes, n, may vary as per the procedures described in section 3, w, ß and m, must be predefined values. The value of m in practical implementations is almost certain to be determined by the particular cryptographic hashing and signing scheme used in the implementation, and as such, will be ignored as a constant in this section. However, w and ß should be carefully selected dependent on the nature of the network used in the implementation. For example, in the case of Ripstik implemented over Avian Carriers[6], or other carrier technology with which honest nodes cannot possibly achieve a very high throughput, w and ß should be set low enough that the stages described in section 2 are achievable within the limits imposed by the underlying carrier technology. If Ripstik is to be implemented over a network consisting of station wagons full of backup tapes hurtling down highways[7], or other very high bandwidth, low responsiveness networks, it is likely desirable to set w to whatever throughput can be expected from honest nodes, and ß to be a very large value such that each stage can occur outside the latency bounds imposed by the underlying carrier technology.
4.2 Scalability and Redundancy with Increasing Numbers of Nodes
As is described in section 2, the time for each stage, and thus each view and progress of blocks, is defined as a function of n, the number of nodes. As such, while the redundancy of the network will increase proportionally to the number of nodes, so will the latency of the network as defined by the time it takes for new blocks to be proposed, voted on, or committed. While this may be acceptable in applications for which the maximum amount of redundancy is desirable, even at the cost of total throughput, there exists a mechanism by which an implementation of Ripstik can become “competitive”, and retain only the top nodes contributing the most throughput, and thus allow for a fixed degree of redundancy with a fixed or even increasing throughput.
4.3 Dynamic Throughput Requirement as “Mining Difficulty”
In Nakamoto Consensus, the probabilistic number of hashes needed to mine a block is determined by a “difficulty”, which is a maximum value of the hashed result of the predecessor block’s header and a nonce, and as more miners attempt to mine blocks, and the total hash power of the network increases, to keep the block times roughly consistent, this difficulty is adjusted every 2016 blocks[3]. In Ripstik, it is possible to achieve a similar effect by setting a fixed time for each stage rather than scaling the allowed time as a function of n. While more nodes may be added, the amount of throughput a node must have to avoid being ejected from the network, w, will increase as the number of nodes, n, increases. As such, the slowest nodes will be ejected, leaving only the highest contributing nodes, and the network can actually strengthen itself through this competition. In this sense, by setting a fixed time for each stage, the dynamic throughput requirement, w, functions in a manner analogous to the difficulty parameter of Nakamoto Consensus.
It may also be desirable to set a target redundancy, which takes the form of a value for n at which the time allowed for each phase of a view
Tseng 10

ceases to scale as more nodes are added. For example, consider a network in which the target redundancy is 1000 nodes. Because a minority may be faulty, to attain a redundancy of 1000, the network must have 1999 nodes. In this example network, let ß be 1 megabyte, m be 256 bytes, and w be 100 megabytes per second. As the target redundancy is 1000, and the target value for n is thus 1999, the maximum time in seconds will be allowed for the propose stage of a view may be calculated as:
n⋅ß n2⋅m w +2⋅w
which is equal to:
1999 ⋅ 1 + 19992 ⋅ 0.000256 100 2⋅100
The maximum time in seconds that will be allowed for the vote stage may be calculated as:
n⋅ß n⋅(n+1)⋅m w+ 2⋅w
which is equal to:
1999 ⋅ 1 + 1999 ⋅ 2000 ⋅ 0.000256 100 2 ⋅ 100
The maximum time in seconds that will be allowed for the wait stage may be calculated as:
n2 ⋅ m = 19992 ⋅ 0.000256 2 ⋅ w 2 ⋅100
Rounding to three decimal places, the maximum times, in seconds are 25.105 seconds for the propose stage, 25.107 seconds for the vote stage, and 5.115 seconds for the wait stage. In total, a view will take a maximum of 55.327 seconds in this hypothetical implementation of Ripstik.
In this example network, because the time for a view will never exceed 55.327 seconds, and no more than half the nodes may be faulty, the throughput of the entire distributed network will
never, on average, be worse than one block every two views, or one megabyte every 110.654 seconds, which may be expressed as a total throughput of 9.037 kilobytes per second. For comparison, the throughput of the bitcoin network cannot exceed 6.667 kilobytes per second due to blocks being limited to 4 megabyte blocks every 600 seconds. This hypothetical example of Ripstik assumed very conservative throughput per node (less than gigabit internet), and a very high degree of redundancy (1000x), and it seems likely that the algorithm could scale much, much higher, given that there is no reason a node operator could not “load balance” the required throughput across multiple network interfaces or even servers.
Furthermore, it is possible to have total network throughput actually increase as more nodes compete to remain in the network by also allowing ß to increase after the number of nodes has increased beyond the point at which the view time exceeds its maximum, for example, if ß were to be increased by 0.1% for every node beyond the desired redundancy that remains in the network.
5 Conclusions
Ripstik represents an interesting hybrid of “traditional” consensus algorithms that offer finality, but limit participation to a known set of nodes, and Nakamoto Consensus, which allows for arbitrary node participation at the cost of requiring heavy and wasteful computation, and the trade-off of probabilistic finality. Ripstik allows for the network to securely expand beyond a fixed, known set of nodes by implementing a resource barrier to Sybil attacks, but also uses the resources contributed by nodes productively, as the throughput requirement of Ripstik is used to send and forward the large number of messages required by traditional consensus algorithms. Ripstik also offers finality like a traditional consensus protocols, something that is not offered by Nakamoto Consensus. In distributed ledger applications, this finality offered by Ripstik is likely to be of great value in increasing practical responsiveness, as it is no longer necessary to wait for the block containing a transaction to be
Tseng 11
      
“buried” under an arbitrary number of blocks for it to be probabilistically secure enough against orphaningthatthetransactionisconsideredsecure.
Furthermore, through the dynamic difficulty mechanism and competition described in section 4.3, if an implementation of Ripstik offers a strong incentive for node operators to remain in the network, it seems likely that such a network could scale arbitrarily, either in throughput or redundancy, which is a challenge for other existing consensus protocols. As an additional advantage, because Ripstik’s throughput is inherently and provably tied to its underlying infrastructure, implementations are likely to be very stable, not producing orphaned blocks, nor suffering from resource exhaustion, as is possible with consensus algorithms that are completely abstracted from underlying infrastructure, such as Nakamoto Consensus or Proof of Stake. As such, Ripstik represents an interesting potential consensus protocol for applications requiring relatively high resource efficiency, throughput, scalability and stability.
Acknowledgments
The author would like to thank the Thiel Foundation, Thiel Fellowship, and, in particular, Allyson Dias, for continued helpful feedback and support.
References
[1] Abraham, I., Malkhi, D., Nayak, K., Ling, R., Maofan, Y.: Sync hotstuff: Simple and
practical synchronous state machine replication. IACR Cryptology ePrint Archive, Report
2019/270 (2019)
Note that Sync Hotstuff, as referenced in this document, is that as described in the updated version:
[2] A. Momose and J. P. Cruz, “Force-locking attack on sync hotstuff,”
Cryptology ePrint Archive, Report 2019/1484, 2019.
[3] S. Nakamoto, “Bitcoin: A peer-to-peer electronic cash system,” 2008.
[4] M. Castro, B. Liskov et al., “Practical byzantine fault tolerance,” in
OSDI, vol. 99, 1999, pp. 173–186.
[5] Stefan Saroiu, P. Krishna Gummadi and Steven
D. Gribble. A Measurement Study of Peer-to-
Peer File Sharing Systems. Technical Report UW-CSE-01-06-02, University of Washington,
Department of Computer Science and Engineering,
July 2001.
[6]IETFRFC1149
[7] Andrew Tanenbaum famously said, “Never underestimate the bandwidth of a station wagon full of tapes hurtling down the highway.”
[8] Based on numerous news reports, and the “Cambridge Bitcoin Energy Consumption Index”, a tool published by the Cambridge Center for Alternative Finance. At the time of this writing (February, 2022) it shows the Bitcoin network exceeding the energy consumption of Norway.
[9] The recent (as of this writing in February 2022) outages and instability/failure to reach consensus of the Solana network, due to “Network Congestion” provide a very good example of this. https://status.solana.com/incidents/6tp7jy94r4r9
